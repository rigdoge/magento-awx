---
- name: 申请和管理 SSL 证书
  hosts: all
  gather_facts: no
  become: yes
  vars:
    # 指定 Nginx Pod 所在的命名空间
    namespace: "{{ namespace | default('default') }}"
    domain_name: "{{ domain_name }}"
    email_address: "{{ email_address }}"
    use_staging: "{{ staging | default(true) }}"
    # 主机上用于存放验证文件的目录，将通过 hostPath 挂载到 Nginx Pod 中
    webroot_path: "/var/www/certbot"
  
  tasks:
    - name: 检查主机上的 certbot 是否已安装
      shell: |
        set -x
        if ! command -v certbot &> /dev/null; then
          echo "请先在主机上运行 install-certbot-base.yml 安装 certbot"
          exit 1
        fi
        certbot --version
      register: certbot_check

    - name: 获取 Nginx Pod 名称
      shell: |
        set -x
        echo "=== 获取 Nginx Pod ==="
        
        # 获取 Pod 名称
        POD_NAME=$(kubectl get pods -n {{ namespace }} -l app=nginx -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$POD_NAME" ]; then
          echo "未找到 Nginx Pod"
          exit 1
        fi
        echo $POD_NAME
      register: pod_name
      
    - name: 显示 Pod 信息
      debug:
        msg: "Nginx Pod: {{ pod_name.stdout }}"

    - name: 安装依赖
      shell: |
        set -x
        echo "=== 安装依赖 ==="
        
        # 更新包管理器
        apt-get update
        
        # 安装依赖
        apt-get install -y \
          python3-pip \
          python3-venv \
          snapd
        
        # 确保 snap 正常运行
        systemctl start snapd
        systemctl enable snapd
      register: deps_result
      
    - name: 显示依赖安装结果
      debug:
        msg: "{{ deps_result.stdout_lines }}"

    - name: 安装 certbot
      shell: |
        set -x
        echo "=== 安装 certbot ==="
        
        # 删除可能存在的旧版本
        apt-get remove -y certbot || true
        rm -f /usr/bin/certbot
        
        # 安装最新版本
        snap install --classic certbot
        
        # 创建软链接
        ln -sf /snap/bin/certbot /usr/bin/certbot
        
        # 验证安装
        echo "验证 certbot 安装："
        which certbot
        certbot --version
      register: install_result
      
    - name: 显示安装结果
      debug:
        msg: "{{ install_result.stdout_lines }}"

    - name: 确认 certbot 可用
      shell: |
        set -x
        echo "=== 确认 certbot 可用 ==="
        
        # 检查命令是否存在
        if ! command -v certbot &> /dev/null; then
          echo "certbot 命令不可用！"
          exit 1
        fi
        
        # 显示版本信息
        certbot --version
      register: certbot_check

    - name: 创建主机上的 webroot 目录（用于存放验证文件）
      file:
        path: "{{ webroot_path }}"
        state: directory
        mode: '0755'
      become: true

    - name: 修改 nginx deployment 以使用 hostPath（让 Nginx Pod 访问主机上的验证文件）
      shell: |
        set -x
        echo "=== 修改 Nginx Deployment ==="
        
        # 添加 hostPath 卷，将主机的验证目录挂载到 Pod 中
        cat > /tmp/nginx-deploy-patch.yaml << EOF
        spec:
          template:
            spec:
              volumes:
              - name: webroot
                hostPath:
                  path: {{ webroot_path }}
                  type: Directory
              containers:
              - name: nginx
                volumeMounts:
                - name: webroot
                  mountPath: {{ webroot_path }}
        EOF
        
        # 应用修改
        kubectl -n {{ namespace }} patch deployment nginx --patch-file /tmp/nginx-deploy-patch.yaml
        
        # 等待 Pod 重启完成
        echo "等待 Pod 重启..."
        kubectl -n {{ namespace }} rollout status deployment/nginx --timeout=60s
      register: patch_result
      
    - name: 显示修改结果
      debug:
        msg: "{{ patch_result.stdout_lines }}"

    - name: 等待新的 Pod 就绪
      shell: |
        set -x
        # 等待 Pod 变为 Running 状态
        for i in $(seq 1 12); do
          POD_STATUS=$(kubectl -n {{ namespace }} get pods -l app=nginx -o jsonpath='{.items[0].status.phase}')
          if [ "$POD_STATUS" = "Running" ]; then
            break
          fi
          sleep 5
        done
        
        # 获取新的 Pod 名称
        kubectl -n {{ namespace }} get pods -l app=nginx -o jsonpath='{.items[0].metadata.name}'
      register: new_pod
      
    - name: 显示新 Pod 信息
      debug:
        msg: "新的 Nginx Pod: {{ new_pod.stdout }}"

    - name: 更新 Pod 名称变量
      set_fact:
        nginx_pod:
          stdout: "{{ new_pod.stdout }}"

    - name: 在 nginx pod 中创建 webroot 目录
      shell: kubectl -n {{ namespace }} exec {{ nginx_pod.stdout }} -- mkdir -p {{ webroot_path }}
      ignore_errors: true

    - name: 配置 nginx 以服务验证文件
      copy:
        content: |
          # 临时配置，仅用于证书验证
          server {
            listen 80 default_server;
            server_name {{ domain_name }};
            
            # 开启调试日志
            error_log /var/log/nginx/error.log debug;
            access_log /var/log/nginx/access.log combined buffer=512k flush=1s;
            
            # 用于 Let's Encrypt 验证
            location /.well-known/acme-challenge/ {
                root {{ webroot_path }};
                default_type text/plain;
                autoindex on;
                
                # 添加调试信息
                add_header X-Debug-Path $document_root$uri;
                add_header X-Debug-Uri $uri;
                
                # 放宽文件访问限制
                allow all;
            }

            # 暂时返回成功
            location / {
                return 200 'OK';
            }
          }
        dest: /tmp/certbot-location.conf
      become: true

    - name: 复制 nginx 配置到 pod
      shell: |
        set -x
        echo "=== 复制并检查 Nginx 配置 ==="
        
        # 复制配置文件
        kubectl -n {{ namespace }} cp /tmp/certbot-location.conf {{ nginx_pod.stdout }}:/etc/nginx/conf.d/default.conf
        
        # 检查配置文件内容
        echo "配置文件内容："
        kubectl -n {{ namespace }} exec {{ nginx_pod.stdout }} -- cat /etc/nginx/conf.d/default.conf
        
        # 测试配置
        echo "测试 Nginx 配置："
        kubectl -n {{ namespace }} exec {{ nginx_pod.stdout }} -- nginx -t
        
        # 重新加载配置
        echo "重新加载 Nginx："
        kubectl -n {{ namespace }} exec {{ nginx_pod.stdout }} -- nginx -s reload
      register: nginx_config_copy_result

    - name: 显示 Nginx 配置复制结果
      debug:
        msg: "{{ nginx_config_copy_result.stdout_lines }}"

    - name: 创建主机上的验证目录
      shell: |
        set -x
        echo "=== 创建主机验证目录 ==="
        
        # 创建目录并设置权限
        mkdir -p {{ webroot_path }}/.well-known/acme-challenge
        chown -R www-data:www-data {{ webroot_path }}
        chmod -R 755 {{ webroot_path }}
        
        # 显示目录权限
        echo "目录权限："
        ls -la {{ webroot_path }}
        ls -la {{ webroot_path }}/.well-known
        ls -la {{ webroot_path }}/.well-known/acme-challenge
      register: host_dir_result

    - name: 创建并复制测试文件
      shell: |
        set -x
        echo "=== 创建测试文件 ==="
        
        # 在主机上创建测试文件
        echo "test123" > {{ webroot_path }}/.well-known/acme-challenge/test.txt
        chown www-data:www-data {{ webroot_path }}/.well-known/acme-challenge/test.txt
        chmod 644 {{ webroot_path }}/.well-known/acme-challenge/test.txt
        
        # 显示文件权限
        echo "文件权限："
        ls -la {{ webroot_path }}/.well-known/acme-challenge/test.txt
        
        # 测试文件访问
        echo "使用 curl 测试文件访问："
        curl -v http://localhost/.well-known/acme-challenge/test.txt || true
        
        # 检查 Nginx 访问日志
        echo "Nginx 访问日志："
        kubectl -n {{ namespace }} exec {{ nginx_pod.stdout }} -- tail -n 5 /var/log/nginx/access.log || true
        
        # 检查 Nginx 错误日志
        echo "Nginx 错误日志："
        kubectl -n {{ namespace }} exec {{ nginx_pod.stdout }} -- tail -n 5 /var/log/nginx/error.log || true
      register: test_file_result

    - name: 检查 Nginx 进程
      shell: |
        set -x
        echo "=== 检查 Nginx 进程 ==="
        
        # 检查 Pod 状态
        echo "Pod 状态："
        kubectl -n {{ namespace }} get pod {{ nginx_pod.stdout }} -o wide
        
        # 检查 Pod 描述
        echo "Pod 描述："
        kubectl -n {{ namespace }} describe pod {{ nginx_pod.stdout }}
        
        # 检查 Nginx 进程
        echo "Nginx 进程信息："
        kubectl -n {{ namespace }} exec {{ nginx_pod.stdout }} -- ps aux | grep nginx || true
      register: nginx_process_result
      
    - name: 显示 Nginx 进程检查结果
      debug:
        msg: "{{ nginx_process_result.stdout_lines }}"

    - name: 检查 Nginx 配置
      shell: |
        set -x
        echo "=== 检查 Nginx 配置 ==="
        
        # 测试配置
        echo "配置测试："
        kubectl -n {{ namespace }} exec {{ nginx_pod.stdout }} -- nginx -t || true
        
        # 重新加载配置
        echo "重新加载 Nginx："
        kubectl -n {{ namespace }} exec {{ nginx_pod.stdout }} -- nginx -s reload || true
      register: nginx_config_check
      
    - name: 显示 Nginx 配置检查结果
      debug:
        msg: "{{ nginx_config_check.stdout_lines }}"

    - name: 测试验证文件访问
      shell: |
        set -x
        echo "=== 测试验证文件访问 ==="
        curl -m 5 -v http://{{ domain_name }}/.well-known/acme-challenge/test.txt
      register: test_access_result
      ignore_errors: yes
      
    - name: 显示测试访问结果
      debug:
        msg: "{{ test_access_result.stdout_lines + test_access_result.stderr_lines }}"

    - name: 申请证书（在主机上运行 certbot）
      shell: |
        set -x
        echo "=== 申请证书 ==="
        
        # 显示 certbot 版本
        certbot --version
        
        # 检查 webroot 目录
        echo "Webroot 目录内容："
        ls -la {{ webroot_path }}/.well-known/acme-challenge/
        
        # 在主机上运行 certbot 申请证书
        # 证书文件将保存在主机的 /etc/letsencrypt/live/{{ domain_name }}/ 目录
        certbot certonly \
          --webroot \
          -w {{ webroot_path }} \
          -d {{ domain_name }} \
          --email {{ email_address }} \
          --agree-tos \
          --non-interactive \
          --debug-challenges \
          -v \
          {% if use_staging %}--staging{% endif %}
        
        # 立即检查证书
        if ! certbot certificates | grep -q "{{ domain_name }}"; then
          echo "证书申请失败！"
          exit 1
        fi
        
        echo "证书申请成功！"
      register: cert_result
      
    - name: 显示证书申请结果
      debug:
        msg: "{{ cert_result.stdout_lines + cert_result.stderr_lines }}"

    - name: 确认证书存在
      shell: |
        if [ ! -f /etc/letsencrypt/live/{{ domain_name }}/fullchain.pem ]; then
          echo "证书文件不存在！"
          exit 1
        fi
      register: cert_check

    - name: 检查证书
      shell: certbot certificates
      register: cert_check_result
      
    - name: 显示证书检查结果
      debug:
        msg: "{{ cert_check_result.stdout_lines }}"

    - name: 检查证书文件
      shell: ls -la /etc/letsencrypt/live/{{ domain_name }}/
      register: cert_files_result
      ignore_errors: yes
      
    - name: 显示证书文件列表
      debug:
        msg: "{{ cert_files_result.stdout_lines }}"

    - name: 配置自动续期
      shell: |
        set -x
        echo "=== 配置自动续期 ==="
        
        # 测试自动续期
        certbot renew --dry-run {% if use_staging %}--staging{% endif %}
        
        # 添加续期前后的钩子
        mkdir -p /etc/letsencrypt/renewal-hooks/pre
        mkdir -p /etc/letsencrypt/renewal-hooks/post
        
        # 创建续期前停止 Nginx 的脚本
        cat > /etc/letsencrypt/renewal-hooks/pre/stop-nginx.sh << 'EOF'
        #!/bin/bash
        kubectl -n {{ namespace }} scale deployment nginx --replicas=0
        EOF
        
        # 创建续期后启动 Nginx 的脚本
        cat > /etc/letsencrypt/renewal-hooks/post/start-nginx.sh << 'EOF'
        #!/bin/bash
        kubectl -n {{ namespace }} scale deployment nginx --replicas=1
        EOF
        
        # 设置执行权限
        chmod +x /etc/letsencrypt/renewal-hooks/pre/stop-nginx.sh
        chmod +x /etc/letsencrypt/renewal-hooks/post/start-nginx.sh
      register: renew_result
      
    - name: 显示自动续期配置结果
      debug:
        msg: "{{ renew_result.stdout_lines }}"

    - name: 检查主机上的证书
      shell: |
        set -x
        echo "=== 检查主机证书 ==="
        
        # 检查证书目录
        echo "证书目录内容："
        ls -la /etc/letsencrypt/live/{{ domain_name }}/ || true
        
        # 检查证书权限
        echo "证书权限："
        stat /etc/letsencrypt/live/{{ domain_name }}/fullchain.pem || true
        
        # 检查证书内容
        echo "证书信息："
        certbot certificates || true
      register: host_cert_result
      
    - name: 显示主机证书检查结果
      debug:
        msg: "{{ host_cert_result.stdout_lines }}"

    - name: 复制证书到 Nginx Pod（从主机复制到 Pod）
      shell: |
        set -x
        echo "=== 复制证书到 Nginx Pod ==="
        
        # 获取 Pod 名称
        POD_NAME=$(kubectl get pods -n {{ namespace }} -l app=nginx -o jsonpath='{.items[0].metadata.name}')
        echo "Pod 名称: $POD_NAME"
        
        # 检查主机上的源证书文件
        echo "检查主机上的源证书文件..."
        ls -la /etc/letsencrypt/live/{{ domain_name }}/
        
        # 创建 Pod 中的目录
        echo "创建证书目录..."
        kubectl -n {{ namespace }} exec $POD_NAME -- mkdir -p /etc/letsencrypt/live/{{ domain_name }}
        kubectl -n {{ namespace }} exec $POD_NAME -- chmod 755 /etc/letsencrypt/live/{{ domain_name }}
        
        # 从主机复制证书文件到 Pod
        echo "复制证书文件..."
        for cert in fullchain.pem privkey.pem chain.pem; do
          echo "复制 $cert..."
          kubectl -n {{ namespace }} cp /etc/letsencrypt/live/{{ domain_name }}/$cert {{ namespace }}/$POD_NAME:/etc/letsencrypt/live/{{ domain_name }}/$cert
          kubectl -n {{ namespace }} exec $POD_NAME -- chmod 644 /etc/letsencrypt/live/{{ domain_name }}/$cert
        done
        
        # 验证复制结果
        echo "验证证书文件..."
        kubectl -n {{ namespace }} exec $POD_NAME -- ls -la /etc/letsencrypt/live/{{ domain_name }}/
        
        # 检查 Nginx 是否能读取证书
        echo "测试 Nginx 读取证书..."
        kubectl -n {{ namespace }} exec $POD_NAME -- nginx -t
      register: copy_result
      
    - name: 显示复制结果
      debug:
        msg: "{{ copy_result.stdout_lines }}"

    - name: 配置自动续期
      ansible.builtin.cron:
        name: "certbot renew for {{ domain_name }}"
        job: "certbot renew --webroot -w {{ webroot_path }} --deploy-hook 'kubectl -n {{ namespace }} exec $(kubectl -n {{ namespace }} get pods -l app=nginx -o jsonpath='{.items[0].metadata.name}') -- nginx -s reload'"
        special_time: daily
      become: true

    - name: 测试自动续期
      shell: certbot renew --dry-run
      become: true 